#######
FFT演示程序
#######

.. highlight:: python
   :linenothreshold: 10

本章详细介绍如何综合利用之前所学习的numpy，traits，traitsUI和Chaco等多个库，编写一个FFT演示程序。此程序可以帮助你理解FFT是如何将时域信号转换为频域信号的，在开始正式的程序编写之前，让我们来复习一下有关FFT变换的知识，如果你没有学习过FFT，现在就是一个不错的学习机会。

FFT知识复习
=======

FFT变换是针对一组数值进行运算的，这组数的长度N必须是2的整数次幂，例如64, 128, 256等等； 数值可以是实数也可以是复数，通常我们的时域信号都是实数，因此下面都以实数为例。我们可以把这一组实数想像成对某个连续信号按照一定取样周期进行取样而得来，如果对这组N个实数值进行FFT变换，将得到一个有N个复数的数组，我们称此复数数组为频域信号，此复数数组符合如下规律：

* 下标为0和N/2的两个复数的虚数部分为0，
* 下标为i和N-i的两个复数共轭，也就是其虚数部分数值相同、符号相反。

下面的例子演示了这一个规律，先以rand随机产生有8个元素的实数数组x，然后用fft对其运算之后，观察其结果为8个复数，并且满足上面两个条件：

    >>> x = np.random.rand(8)
    >>> x
    array([ 0.15562099,  0.56862756,  0.54371949,  0.06354358,  0.60678158,
            0.78360968,  0.90116887,  0.1588846 ])
    >>> xf = np.fft.fft(x)
    >>> xf
    array([ 3.78195634+0.j        , -0.53575962+0.57688097j,
           -0.68248579-1.12980906j, -0.36656155-0.13801778j,
            0.63262552+0.j        , -0.36656155+0.13801778j,
           -0.68248579+1.12980906j, -0.53575962-0.57688097j])

FFT变换的结果可以通过IFFT变换（逆FFT变换）还原为原来的值：

>>> np.fft.ifft(xf)
array([ 0.15562099 +0.00000000e+00j,  0.56862756 +1.91940002e-16j,
        0.54371949 +1.24900090e-16j,  0.06354358 -2.33573365e-16j,
        0.60678158 +0.00000000e+00j,  0.78360968 +2.75206729e-16j,
        0.90116887 -1.24900090e-16j,  0.15888460 -2.33573365e-16j])

注意ifft的运算结果实际上是和x相同的，由于浮点数的运算误差，出现了一些非常小的虚数部分。

FFT变换和IFFT变换并没有增加或者减少信号的数量，如果你仔细数一下的话，x中有8个实数数值，而xf中其实也只有8个有效的值。

.. topic:: 计算FFT结果中的有用的数值

    由于虚数部共轭和虚数部为0等规律，真正有用的信息保存在下标从0到N/2的N/2+1个虚数中， 又由于下标为0和N/2的值虚数部分为0，因此只有N个有效的实数值。

下面让我们来看看FFT变换之后的那些复数都代表什么意思。

* 首先下标为0的实数表示了时域信号中的直流成分的多少
* 下标为i的复数a+b*j表示时域信号中周期为N/i个取样值的正弦波和余弦波的成分的多少， 其中a表示cos波形的成分，b表示sin波形的成分

让我们通过几个例子来说明一下，下面是对一个直流信号进行FFT变换：

    >>> x = np.ones(8)
    >>> x
    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
    >>> np.fft.fft(x)/len(x)
    array([ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,
            0.+0.j])

所谓直流信号，就是其值不随时间变化，因此我们创建一个值全为1的数组x，我们看到它的FFT结果除了下标为0的数值不为0以外，其余的都为0。(为了计算各个成分的能量多少，需要将FFT的结果除以FFT的长度)，这表示我们的时域信号是直流的，并且其成分为1。

下面我们产生一个周期为8个取样的正弦波，然后观察其FFT的结果：

    >>> x = np.arange(0, 2*np.pi, 2*np.pi/8)
    >>> y = np.sin(x)
    >>> np.fft.fft(y)/len(y)
    array([  1.42979161e-18 +0.00000000e+00j,
            -4.44089210e-16 -5.00000000e-01j,
             1.53075794e-17 -1.38777878e-17j,
             3.87737802e-17 -1.11022302e-16j,
             2.91853672e-17 +0.00000000e+00j,
             0.00000000e+00 -9.71445147e-17j,
             1.53075794e-17 +1.38777878e-17j,   3.44085112e-16 +5.00000000e-01j])
         
.. topic:: 如何用linspace创建取样点x

    要计算周期为8个取样的正弦波，就需要把0-2*pi的区间等分为8分，如果用np.linspace(0, 2*np.pi, 8)的话，产生的值为：
    
    >>> np.linspace(0, 2*np.pi, 8)
    array([ 0.        ,  0.8975979 ,  1.7951958 ,  2.6927937 ,  3.5903916 ,
        4.48798951,  5.38558741,  6.28318531])
    >>> 2*np.pi / 0.8975979
    7.0000000079986666

    可以看出上面用linspace只等分为7份，如果要正确使用np.linspace的话， 可以如下调用，产生9个点，并且设置endpoint=False，最终结果不包括最后的那个点：
    
    >>> np.linspace(0, 2*np.pi, 9, endpoint=False)
    array([ 0.        ,  0.6981317 ,  1.3962634 ,  2.0943951 ,  2.7925268 ,
            3.4906585 ,  4.1887902 ,  4.88692191,  5.58505361])
            
让我们再来看看对正弦波的FFT的计算结果吧。可以看到下标为1的复数的虚数部分为-0.5，而我们产生的正弦波的放大系数(振幅)为1，它们之间的关系是-0.5*（-2）=1。再来看一下余弦波形:

    >>> np.fft.fft(np.cos(x))/len(x)
    array([ -4.30631550e-17 +0.00000000e+00j,
             5.00000000e-01 -2.52659764e-16j,
             1.53075794e-17 +0.00000000e+00j,
             1.11022302e-16 +1.97148613e-16j,
             1.24479962e-17 +0.00000000e+00j,
            -1.11022302e-16 +1.91429446e-16j,
             1.53075794e-17 +0.00000000e+00j,   5.00000000e-01 -1.35918295e-16j])

只有下标为1的复数的实数部分有有效数值0.5，和余弦波的放大系数1之间的关系是0.5*2=1。再来看2个例子：

    >>> np.fft.fft(2*np.sin(2*x))/len(x)
    array([  6.12303177e-17 +0.00000000e+00j,
             6.12303177e-17 +6.12303177e-17j,
            -1.83690953e-16 -1.00000000e+00j,
             6.12303177e-17 -6.12303177e-17j,
             6.12303177e-17 +0.00000000e+00j,
             6.12303177e-17 +6.12303177e-17j,
            -1.83690953e-16 +1.00000000e+00j,   6.12303177e-17 -6.12303177e-17j])
    >>> np.fft.fft(0.8*np.cos(2*x))/len(x)
    array([ -2.44921271e-17 +0.00000000e+00j,
            -3.46370983e-17 +2.46519033e-32j,
             4.00000000e-01 -9.79685083e-17j,
             3.46370983e-17 -3.08148791e-32j,
             2.44921271e-17 +0.00000000e+00j,
             3.46370983e-17 -2.46519033e-32j,
             4.00000000e-01 +9.79685083e-17j,  -3.46370983e-17 +3.08148791e-32j])

上面产生的是周期为4个取样(N/2)的正弦和余弦信号，其FFT的有效成分在下标为2的复数中，其中正弦波的放大系数为2,因此频域虚数部分的值为-1；余弦波的放大系数为0.8，因此其对应的值为0.4。

同频率的正弦波和余弦波通过不同的系数叠加，可以产生同频率的各种相位的余弦波，因此我们可以这样来理解频域中的复数:

* 复数的模（绝对值）代表了此频率的余弦波的振幅
* 复数的辐角代表了此频率的余弦波的相位

让我们来看最后一个例子：

    >>> x = np.arange(0, 2*np.pi, 2*np.pi/128)
    >>> y = 0.3*np.cos(x) + 0.5*np.cos(2*x+np.pi/4) + 0.8*np.cos(3*x-np.pi/3)
    >>> yf = np.fft.fft(y)/len(y)
    >>> yf[:4]
    array([  1.00830802e-17 +0.00000000e+00j,
             1.50000000e-01 +6.27820821e-18j,
             1.76776695e-01 +1.76776695e-01j,   2.00000000e-01 -3.46410162e-01j])
    >>> np.angle(yf[1])
    4.1854721366992471e-017
    >>> np.abs(yf[1]), np.rad2deg(np.angle(yf[1]))
    (0.15000000000000008, 2.3980988870246962e-015)
    >>> np.abs(yf[2]), np.rad2deg(np.angle(yf[2]))
    (0.25000000000000011, 44.999999999999993)
    >>> np.abs(yf[3]), np.rad2deg(np.angle(yf[3]))
    (0.39999999999999991, -60.000000000000085)

在这个例子中我们产生了三个不同频率的余弦波，并且给他们不同的振幅和相位：

* 周期为128/1.0点的余弦波的相位为0， 振幅为0.3
* 周期为64/2.0点的余弦波的相位为45度， 振幅为0.5
* 周期为128/3.0点的余弦波的相位为-60度，振幅为0.8

对照yf[1], yf[2], yf[3]的复数振幅和辐角，我想你应该对FFT结果中的每个数值所表示的意思有很清楚的理解了吧。

合成时域信号
======

前面说过通过ifft函数可以将频域信号转换回时域信号，这种转换是精确的。下面我们要写一个小程序，完成类似的事情，不过可以由用户选择只转换一部分频率回到时域信号，这样转换的结果和原始的时域信号会有误差，我们通过观察可以发现使用的频率信息越多，则此误差越小，直观地看到如何通过多个余弦波逐步逼近任意的曲线信号的:

.. literalinclude:: examples/fft_example.py

.. _fig-fftstudy01::

.. figure:: images/fft_study_01.png
    :width: 14cm

    三角波的频谱

.. _fig-fftstudy02:
    
.. figure:: images/fft_study_02.png
    :width: 14cm

    部分频谱重建的三角波

第18行的triangle_wave函数产生一个周期的三角波形，注意我们使用np.where函数计算区间函数的值。triangle函数返回两个数组，分别表示x轴和y轴的值。注意后面的计算和绘图不使用x轴坐标，而是直接用取样次数作为x轴坐标。

第7行的fft_combine的函数使用fft的结果freqs中的前n个数据重新合成时域信号，由于合成所使用的信号都是正弦波这样的周期信号，所以我们可以通过第三个参数loops指定计算几个周期。

通过这个例子，我们可以看出使用的频率越多，最终合成的波形越接近原始的三角波。

.. topic:: 合成方波

    由于方波的波形中存在跳变，因此用有限个正弦波合成的方波在跳变出现抖动现象，如\ :tref:`下图,fig-fftstudy03`\ 所示，用正弦波合成的方波的收敛速度比三角波慢得多：
    
    计算方波的波形可以采用如下的函数： ::

        def square_wave(size):
            x = np.arange(0, 1, 1.0/size)
            y = np.where(x<0.5, 1.0, 0)
            return x, y

.. _fig-fftstudy03:

.. figure:: images/fft_study_03.png
    :width: 14cm

    正弦波合成方波在跳变处出现都抖动\ :tlabel:`fig-fftstudy03`

三角波FFT演示程序
==========

我们希望制作一个用户友好的界面，交互式地观察各种三角波的频谱以及其正弦合成的近似波形。 制作界面是一件很费工的事情，幸好我们有TraitsUI库的帮忙，不到200行程序就可以制作出如下的效果了:

.. htmlonly::

    .. raw:: html
       
        <OBJECT CLASSID="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" WIDTH="589" HEIGHT="447" CODEBASE="http://active.macromedia.com/flash5/cabs/swflash.cab#version=7,0,0,0">
        <PARAM NAME="movie" VALUE="_images/fft_study_04.swf">
        <PARAM NAME="play" VALUE="true">
        <PARAM NAME="loop" VALUE="false">
        <PARAM NAME="wmode" VALUE="transparent">
        <PARAM NAME="quality" VALUE="high">
        <EMBED SRC="_images/fft_study_04.swf" width="589" HEIGHT="447" quality="high" loop="false" wmode="transparent" TYPE="application/x-shockwave-flash" PLUGINSPAGE="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash">
        </EMBED>
        </OBJECT>
        <img src="_images/fft_study_04.swf" style="visibility:hidden"/>
    
.. latexonly::

    .. _fig-fftstudy04:
    
    .. figure:: images/fft_study_04.png
    
        三角波频谱观察器界面，请查看本书的HTML版本观赏Flash动画    
    
程序中已经给出了详细的注释，相信大家能够读懂并掌握这类程序的写法，其中需要注意的几点:

* 16行，用ScrubberEditor创建一个自定义样式的拖动调整值的控件，77-80行设置Item的editor = scrubber，这样就用我们自定义的控件修改trait属性了，如果不指定editor的话，Range类型的trait属性将以一个滚动条做为编辑器。

* 用Range traits可以指定一个带范围的属性，它可以设置上限下限，上下限可以用整数或者浮点数直接指定，也可以用另外一个trait属性指定(用字符串指定trait属性名)，但是几种类型不能混用，因此程序中专门设计了两个常数的trait属性(36, 37行)，它们的作用只是用来指定其它trait属性的上下限。 ::

        low = Float(0.02)
        hi = Float(1.0)
        
* 190行的triangle_func函数返回一个用frompyfunc创建的ufunc函数，150行用此函数计算三角波，但是用frompyfunc创建的ufunc函数返回的数组的元素的类型(dtype)为object，因此需要用cast["float64"]函数强制将其转换为类型为float64的数组。

* 处理trait属性的改变事件最简单的方式就是用固定的函数名: _trait属性名_changed，但是当多个trait属性需要共用某一个处理函数时，用@on_trait_change更加简洁。
      
下面是完整的程序:

.. literalinclude:: examples/fft_triangle_GUI.py

